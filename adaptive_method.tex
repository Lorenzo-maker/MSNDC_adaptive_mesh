\section*{$p^n h$-ADAPTIVE MESH REFINEMENT METHOD}

In this section a $\pnh$-adaptive mesh refinement method is developed. In particular, the generic OCP problem is first transcribed into an NLP using the \emph{direct collocation} method, explained above, then the mesh refinement method is applied to the obtained optimal solution.
The $\pnh$ method explained here, is very closed to the one explained in~\cite{Patterson:OCAM:2015}. In particular, the method for estimating the error in the current solution is very close to the cited article. The key aspect that differentiate this work from the  work of Patterson et al. is the refinement strategy.
In~\cite{Patterson:OCAM:2015}, the adjustment of polynomial degree is made in a way that all states are represented by the same degree. Instead, in this work the $p$-refinement is differentiate for each state. Then, in both papers if the degree approach to reach convergence failed, the mesh spacing is adjusted.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Error Estimate}

In this section, an estimate of the relative error in the solution within a mesh interval is derived. The error is calculated in each mesh interval, for each state.
The key idea is to compare the optimal state obtained from the NLP solution, with a more accurate approximation of the state.

To explain in details this aspect, consider the $i$-th state on the generic $S_k$ mesh interval.
The solution of NLP gives as output a polynomial approximation of the state, that has been called $\Xkidki (\tau)$.
If the problem solution is suppose to be smooth, a polynomial approximation obtained with an increase number of Gauss-Legendre points should yield a state that more accurately satisfies the dynamics.
Suppose that the error has to be estimated at a set of  $\dkip = \dki + 1$ collocation points, that consistent whit the proposed notation are indicated by $\taudkip$.
The values of the NLP solution in these points are denoted by $\Xkidki (\taudkip_j)$ for $j = 1, \dots, \dkip$.
Then the improved approximation of the state is constructed by using the value of the right-hand side of the dynamics at these new Gauss-Legendre points.
Let $\barXkidkip (\tau)$ be a polynomial of degree $\dkip$ that is defined for the $i$-th state on the $S_k$ interval. If the derivative of this polynomial matches the dynamics at each $\taudkip$ collocation points, $\barXkidkip (\tau)$ can be obtained by a numerical integration using the resulting quadrature scheme

\begin{subequations}
\begin{align}
	&\barXkidkip (\tau) = \sum_{m=1}^{\dkip}\Big(\int_{0}^{\tau}\lmdki (\tau)d\tau\Big) f_i\Big(\Xkd(\taudkip_m), U_k\Big), \hspace{2mm} \text{where} \label{eq:barX}\\
	&  \lmdki (\tau) = \prod_{r=1, r\neq m}^{\dkip} \dfrac{\tau - \taudkip_r}{\taudkip_m - \taudkip_r}. \label{eq:meshlm}
\end{align}

\end{subequations}

Hence $\barXkidkip (\tau)$ represents the improved approximation and its values in $\taudkip$ will be denoted by $\barXkidkip (\taudkip_j)$ for $j = 1, \dots, \dkip$.

Defined these quantities it is possible to evaluate the absolute and relative errors for each $\taudkip_j$ of the $i$-th state on the $k$-th interval

\begin{subequations}
	\begin{align}
	&\Ekij = \Big|\barXkidkip (\taudkip_j) - \Xkidki (\taudkip_j)\Big| \label{eq:absolute}\\
	&\ekij = \dfrac{\Ekij}{1 + \max\limits_{j= 1, \dots, \dkip} \Big| \Xkidki (\taudkip_j)\Big|} \label{eq:relative} 
	\end{align}
\end{subequations}

where Eqn.~(\ref{eq:absolute}) and Eqn.~(\ref{eq:relative}) are the absolute and the relative error in the $\taudkip_j$, respectively.

The relative error is use in the next section to implement the $\pnh$ strategy.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Algorithm}
In this section the algorithm implemented for mesh refining is shown. 
Suppose further that it is desired to meet a relative error accuracy tolerance $\epsilon$ in each mesh
interval $S_k$ for $k = 1, \dots, N$. If the tolerance  $\epsilon$  is not met in at least one mesh interval, then the next step is to refine the current mesh, either by dividing the mesh interval or increasing the degree of the approximating polynomial within the mesh interval.
In particular, to make it clearer, the method is shown in a pseudocode form and for the generic $S_k$ mesh interval.
To better understand the pseudocode, it is worth to explain some quantities that appear in it.
Hence, $\dkis$ is the new polynomial degree that has to be chosen, for the $i$-th state in the $S_k$ interval, to reach the prescribed tolerance $\epsilon$. Then $\Bki$ is the number of subinterval into which $S_k$ has to be divided, to respect $\epsilon$, considering the error of the $i$-th state. If $\Bki = 1$, $S_k$ has not to be divided . Instead $d_{min}$ and $d_{max}$ are the maximum and the minimum allowable polynomial degree.

%% Definire dmax, dmin, Bki, d*, epsilon



\begin{algorithm}
\caption{Exploration: Step 1 of the $\pnh$ mesh refinement}\label{alg:step1}
	\begin{algorithmic}[1]
		\For {$i = 1$ to $n_x$}
			\If{$\max\limits_{j= 1, \dots, \dkip} (\ekij) \leq \epsilon$}
				\State $\dkis \gets \dki$
				\State $\Bki \gets 1$  %\Comment{This is a comment}
			\Else
				\State $\Pki \gets \log_{\dki} \Bigg\lceil \max\limits_{j= 1, \dots, \dkip} \Bigg(\dfrac{\ekij}{\epsilon}\Bigg) \Bigg\rceil$
				\State $\dkis \gets \dki + \Pki$
					\If {$ \dkis \leq d_{max}$}
						\State $\Bki \gets 1$		
					\Else
						\State $\Bki \gets \max\Bigg(\Bigg\lceil \dfrac{\dkis}{d_{min}}\Bigg\rceil, 2\Bigg)$
					\EndIf
			\EndIf
		\EndFor
	\end{algorithmic}
\end{algorithm}

In Alg.~\ref{alg:step1} the first step of the proposed refine method is explained. In particular, the quantity $P_{k,i}$ is calculated referring to the method of~\cite{Patterson:OCAM:2015} which is in accordance with the convergence theory summarized in~\cite{Hou:GNC:2012,Hou:PHD:2013}.  After Alg.~\ref{alg:step1} two vectorial quantities are defined $\Dks = [\dksn{1}, \dots, \dksn{i}, \dots, \dksn{n_x}]$ and $\Dk = [\dkg{1}, \dots, \dkg{i}, \dots, \dkg{n_x}]$. Then the refinement step, shown in Alg.~\ref{alg:step2} is performed.

\begin{algorithm}
	\caption{Refinement: Step 2 of the $\pnh$ mesh refinement}\label{alg:step2}
	\begin{algorithmic}[1]
		\If {$\max\limits_{i= 1, \dots, n_x}(\Bki) = 1$}
			\If {$\Dks = \Dk$}
				\State stop algorithm, convergence reached	
			\Else
				\For {$i = 1$ to $n_x$}
					\State $\dki = \dkis$ \Comment p-refinement
				\EndFor
			\EndIf
		\Else
			\For {$i = 1$ to $n_x$}
				\State $\dki = \dki$
				\State $\Bki = \max\limits_{i= 1, \dots, n_x}(\Bki)$ \Comment h-refinement
			\EndFor		
		\EndIf
	\end{algorithmic}
\end{algorithm}


The new mesh for the next NLP, is encoded in the quantity $\dki$ and $\Bki$ for $i = 1, \dots, n_x$ and for $k = 1, \dots, N$.

It is worth to notice that, as explained in Alg.~\ref{alg:step2}, in each interval, if at least one of the state required to split $S_k$, then it is splitted. Instead if no state required it, each state is approximated, in the next NLP, with a polynomial of degree equal to the one proposed by the method.

Finally, the proposed algorithm can match the original mesh refinement method of~\cite{Patterson:OCAM:2015} with two simple steps: (i) The first NLP has to be solved in a way that all the states have the same degree $d_k$ in $S_k$, therefore $\dki = d_k$ (for $i = 1, \dots, n_x$), (ii) The $6$-th line of Alg.~\ref{alg:step2} has to be modified by writing $\dki = \max\limits_{i= 1, \dots, n_x}(\dkis)$. In this way the polynomial approximation maintains always the same degree for all the states.



